Documentation du projet de programmation : ED1A

### Description de toutes les classes :

/src : 
    ─> contient le code source du jeu.

## Partie 1 : Classes qui gèrent une partie :

/gameobjects :
    ・GameObject :
        ├── Implements : Serializable.
        ├── Type : Abstract.
        ├── Classes représentées : Items, Personnage, Plateforme, Projectile.
        ├── Attributs :
        |   └── double x, y, width, height.
        └── Description :
                Représente les différents types d'objets d'une GAME, par des coordonnées et des dimensions.

    ・Personnage :
        ├── Extends : GameObject.
        ├── Attributs : 
        │   ├── double x, y, width, height, dx, dy. 
        │   ├── boolean isRight, isInertRight, isLeft, isInertLeft, isShoot, canShoot.
        │   └── ArrayList<Projectile> listProjectiles.
        └── Description : 
            ├── Représente un personnage. C'est un GameObjet avec une vitesse en x et en y.
            ├── Les champs "isRight" & "isLeft" indique si le joueur appuye sur les boutons droite/gauche ou pas. Ils servent à faire bouger le personnage.
            │   Les champs "isInertRight" & "isInertLeft" gèrent l'inertie, càd que le relâchement du bouton implique un ralentissement de la vitesse du personnage en x, et non un arrêt net.
            │   Les champs "isShoot" et "canShoot" sont liés aux projectiles. isShoot indique si le personnage vient de tirer, & canShoot indique si le personnage à le droit de tirer. Ces champs fonctionnent comme ceci :
            │       Si on a le droit de tirer et que l'on tire (i.e on apuie sur le bouton "tirer"), alors on indique que l'on vient de lancer le processus de tir et que l'on a plus le droit de tirer.
            │       Si on lâche le bouton "tirer", alors on a de nouveau le droit de "tirer".
            │       Si (isShoot && iscanShoot), i.e on vient de lancer le processus de tir & on a le droit de tirer (càd dès qu'on relâche le bouton "tirer"), alors on tire et on indique qu'on ne tir plus. 
            │   Le champs "listProjectiles" stock tous les projectiles lancés par le personnage et qui sont toujours sur le terrain.
            └── La méthode "tirer(double w, double h, double vx, double vy)" ajoute un projectile à la liste des projectiles.
                La méthode "collides_plateforme(Plateforme pf, double deltaTime)" gère la collision entre le personnage et une plateforme. Si collision il y a, alors la vitesse en y change, toujours proportionnelle au deltaTime.
                La méthode "collides_item(Items it, double deltaTime)" gère un cas suplémentaire mais est sensiblement identique.
                        
    ・Plateforme :
        ├── Type : Abstract.
        ├── Classes représentées : PlateformeBase, MovingPlateforme,...
        ├── Extends : GameObject.
        ├── Attributs : 
        │   └── double x, y, width, height, saut.
        └── Description : 
            ├── Représente une plateforme. C'est un GameObjet avec un saut.
            └── Le champs "saut" est une constante qui indique de combien le personnage va sauter en cas de collision. Constante différente en fonction de la plateforme.

    ・PlateformeBase :
        ├── Extends : Plateforme.
        ├── Attributs : 
        │   └── double x, y, width, height, saut.
        └── Description : 
            └── Représente une plateforme basique.

    ・MovingPlateforme :
        ├── Extends : Plateforme.
        ├── Attributs : 
        │   └── double x, y, width, height, saut, dx.
        └── Description :
            ├── Représente une plateforme mobile. C'est une Plateforme avec une vitesse en x (horizontale).
            ├── Le champs "dx" représente la vitesse de la plateforme en x.
            └── La méthode "move(Terrain t)" fait bouger la plateforme en x.

    ・Items :
        ├── Type : Abstract.
        ├── Classes représentées : Fusée, Hélicoptère,...
        ├── Extends : GameObject.
        ├── Attributs : 
        │   ├── double x, y, width, height, saut.
        │   └── boolean isNeedPied.
        └── Description : 
            ├── Représente un item. C'est un GameObjet avec un saut.
            └── Le champs "saut" est une constante qui indique de combien le personnage va sauter en cas de collision. Constante différente en fonction de l'item.
                Le champ "isNeedPied" gère la collision. Il indique si le personnage doit collisionner l'item avec les pieds (ex: ressort...) ou pas forcément (ex : fusée...).

    ・Fusee & Helicoptere :
        ├── Extends : Item.
        ├── Attributs : 
        │   ├── double x, y, width, height, saut.
        │   └── boolean isNeedPied.
        └── Description : 
            ├── Représente une Fusée/Hélicoptère.
            └── La méthode "move" fait bouger l'item en x et y.
    
    ・Projectile :
        ├── Extends : GameObject.
        ├── Attributs : 
        │   └── double x, y, width, height, dx, dy. 
        └── Description : 
            ├── Représente un projectile. C'est un GameObject avec une vitesse en x et en y.
            └── La méthode "limiteProjectile" gère le débordement (la sortie) du projectile par rapport aux limites du terrain.
                La méthode "collides_monster" gère la collision entre le projectile et un monstre.

    ・Terrain :
        ├── Attributs :
        │   ├── ArrayList<Plateforme> plateformesListe.
        │   ├── ArrayList<Joueur> ListeJoueurs.
        │   ├── final double height, width.
        │   ├── double diff_plateformes, difficulty.
        │   ├── boolean multiplayer, isHost.
        │   ├── Serveur host.
        │   ├── JoueurConnecte client.
        │   └── final int playerID.
        └── Description :
            ├── Représente le terrain d'une GAME. Cette classe gère tous les composant d'une partie.
            │
            ├── Le champs "plateformesListe" conttient la liste de toutes les plateformes présentent sur le terrain.
            ├── Le champs "ListeJoueurs" conttient la liste de tous les joueurs présents sur le terrain.
            ├── Les champs "width, height" représentent la dimension du terrain. Celle-ci ne change jamais (final).
            ├── Le champs "difficulty" représente la difficulté du jeu. Plus on avance, plus celle-ci augmente jusqu'à un maximum. La difficulté affecte la densité des plateformes et la probabilité qu'un item bonus/malus apparaisse.
            ├── Le champs "diff_plateformes" représente la différence en y entre 2 plateformes. Plus difficulty augmente, plus la différence est grande.
            └── Les champs "multiplayer", "isHost", "host", "client" "playerID" !!!!!!!!! EXPLICATION CHEZ FARES !!!!!!!!!!!
            │
            ├── Le constructeur initialise les variables et fait appel à la méthode "generateObstacles()".
            ├── La méthode "generateObstacles()" crée la liste des plateformes. Les dimensions sont adaptées à toutes les résolutions. !!!!!!!!! EXPLICATION CHEZ ELYO !!!!!!!!!!
            ├── La méthode "highestPlateforme()" renvoie la plateforme la plus haute sur le terrain.
            ├── La méthode "limite(Personnage)" gère le cas où le personnage déborde d'un côté ou l'autre du terrain. Si plus de la moitié du personnage déborde d'un côté, alors il réapparaît de l'autre côté.
            ├── La méthode "update(double deltaTime)" met à jour les variables du jeu. Elle appelle, pour tous les joueurs, la méthode "update(Joueur j, double deltaTime)".
            └── La méthode "update(Joueur j, double deltaTime)" met à jour les variables du jeu pour un joueur j donné.
                    Cette méthode commence par gérer le ralentissement du personnage, en mettant à jour sa vitesse dy et sa position en y.
                    Ensuite, si les pieds du personnage touche le bas de la fenêtre, le jeu se termine.
                    Puis, elle se charge de mettre à jour la position de tous les projectiles lancés par le joueur.
                    Pour donner cette impression de monter quand on saute, on a décidé arbitrairement que lorsque la tête du personnage atteint la moitié de l'écran en y, toutes les plateformes s'abaissent.
                    À ce moment là, on met à jour la difficulté, le score, et on descend les plateformes, en s'assurant qu'elles restent bien dans le cadre. Dans le cas contraire, on !!!!!!!!!!!!!!!!!!! ELYO EXPLICATION !!!!!!!!!!!!!!!!!!
                    Enfin, on gère la collision entre le personnage et les plateformes, ainsi que le débordement avec "limite(Personnage p)".
            

    
### Modélisation du projet :
└── src
    ├── gameobjects /// Toutes les classes qui gère une partie
    │   ├── Fusee.java
    │   ├── GameObject.java
    │   ├── Helicoptere.java
    │   ├── Items.java // (ABS) Représente un item.
    │   ├── Joueur.java // Représente un joueur.
    │   ├── MovingPlateforme.java
    │   ├── Personnage.java
    │   ├── PlateformeBase.java
    │   ├── Plateforme.java // (ABS) Représente une plateforme.
    │   ├── Projectile.java
    │   └── Terrain.java // (MAIN) Gère tous les éléments d'une partie.
    ├── gui
    │   ├── App.java
    │   ├── Game.java // Représente la fenêtre générale qui contient vue.
    │   ├── Vue.java // (JPanel) S'occupe de tout ce qui est lié à l'affichage.
    │   └── images // Stocke les différents pack de skin
    │       └── packBase // Exemple de pack de skin (tous les packs ont la même structure)
    │           ├── background
    │           │   └──> Contient les différents background.
    │           ├── chiffres
    │           │   └──> Contient des images de chiffres.
    │           ├── icon
    │           │   └──> Contient différents icones.
    │           ├── lettres
    │           │   └──> Contient des images de lettres. 
    │           ├── personnages
    │           │   └──> Contient les différents skin du personnage.
    │           ├── plateformes
    │           │   └──> Contient les différents types de plateformes.
    │           └── items
    |               └──> Contient les différents items du jeu.
    ├── leaderboard // Contient les classes qui gère la sauvegarde des scores et tout ce qui est lié au classement.
    │   ├── classement.csv // Fichier (trié) qui contient les scores de tous les joueurs (classement globale).
    │   ├── Classement.java
    │   ├── history.csv // Fichier (non trié) qui fait offiche de "log locale". Contient l'historique des parties du joueur local.
    │   ├── History.java
    │   └── LeaderBoard.java // (ABS) Sert à représenter le classement et l'historique.
    └── multiplayer
        ├── JoueurConnecte.java
        ├── Serveur.java
        └── ThreadMouvement.java